from _typeshed import Incomplete
from intermine.errors import WebserviceError as WebserviceError
from intermine.lists.list import List as List

P3K: Incomplete

def safe_key(maybe_unicode): ...

class ListManager:
    LOG: Incomplete
    DEFAULT_LIST_NAME: str
    DEFAULT_DESCRIPTION: str
    INTERSECTION_PATH: str
    UNION_PATH: str
    DIFFERENCE_PATH: str
    SUBTRACTION_PATH: str
    service: Incomplete
    lists: Incomplete
    def __init__(self, service) -> None: ...
    def refresh_lists(self) -> None: ...
    @staticmethod
    def safe_dict(d): ...
    def get_list(self, name): ...
    def l(self, name): ...
    def get_all_lists(self): ...
    def get_all_list_names(self): ...
    def get_list_count(self): ...
    def get_unused_list_name(self): ...
    def create_list(self, content, list_type: str = ..., name: Incomplete | None = ..., description: Incomplete | None = ..., tags=..., add=..., organism: Incomplete | None = ...): ...
    def parse_list_upload_response(self, response): ...
    def delete_lists(self, lists) -> None: ...
    def remove_tags(self, to_remove_from, tags): ...
    def add_tags(self, to_tag, tags): ...
    def get_tags(self, im_list): ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, traceback) -> None: ...
    def delete_temporary_lists(self) -> None: ...
    def intersect(self, lists, name: Incomplete | None = ..., description: Incomplete | None = ..., tags=...): ...
    def union(self, lists, name: Incomplete | None = ..., description: Incomplete | None = ..., tags=...): ...
    def xor(self, lists, name: Incomplete | None = ..., description: Incomplete | None = ..., tags=...): ...
    def subtract(self, lefts, rights, name: Incomplete | None = ..., description: Incomplete | None = ..., tags=...): ...
    def make_list_names(self, lists): ...

class ListServiceError(WebserviceError): ...
