from _typeshed import Incomplete
from collections import UserDict
from collections.abc import Generator
from intermine import VERSION as VERSION
from intermine.errors import WebserviceError as WebserviceError
from intermine.model import Attribute as Attribute, Collection as Collection, Reference as Reference

P3K: Incomplete

class EnrichmentLine(UserDict):
    def __getattr__(self, name): ...

class ResultObject:
    selected_attributes: Incomplete
    reference_paths: Incomplete
    def __init__(self, data, cld, view=...) -> None: ...
    def __getattr__(self, name): ...
    @property
    def id(self): ...

class ResultRow:
    data: Incomplete
    views: Incomplete
    index_map: Incomplete
    def __init__(self, data, views) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __call__(self, name): ...
    def __getitem__(self, key): ...
    def to_l(self): ...
    def to_d(self): ...
    def items(self): ...
    def iteritems(self) -> Generator[Incomplete, None, None]: ...
    def keys(self): ...
    def values(self): ...
    def itervalues(self): ...
    def iterkeys(self): ...
    def has_key(self, key): ...

class TableResultRow(ResultRow):
    def __getitem__(self, key): ...
    def to_l(self): ...

def encode_str(s): ...
def decode_binary(b): ...
def encode_dict(input_d): ...

class ResultIterator:
    PARSED_FORMATS: Incomplete
    STRING_FORMATS: Incomplete
    JSON_FORMATS: Incomplete
    ROW_FORMATS: Incomplete
    row: Incomplete
    url: Incomplete
    data: Incomplete
    view: Incomplete
    opener: Incomplete
    cld: Incomplete
    rowformat: Incomplete
    def __init__(self, service, path, params, rowformat, view, cld: Incomplete | None = ...) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __next__(self): ...
    def next(self): ...

class FlatFileIterator:
    connection: Incomplete
    parser: Incomplete
    def __init__(self, connection, parser) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...
    def next(self): ...

class JSONIterator:
    LOG: Incomplete
    connection: Incomplete
    parser: Incomplete
    header: str
    footer: str
    def __init__(self, connection, parser) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...
    def next(self): ...
    def parse_header(self) -> None: ...
    def check_return_status(self) -> None: ...
    def get_next_row_from_connection(self): ...

def encode_headers(headers): ...

class InterMineURLOpener:
    USER_AGENT: Incomplete
    PLAIN_TEXT: str
    JSON: str
    token: Incomplete
    auth_header: Incomplete
    using_authentication: bool
    def __init__(self, credentials: Incomplete | None = ..., token: Incomplete | None = ...) -> None: ...
    def clone(self): ...
    def headers(self, content_type: Incomplete | None = ..., accept: Incomplete | None = ...): ...
    def post_plain_text(self, url, body): ...
    def post_content(self, url, body, mimetype, charset: str = ...): ...
    def open(self, url, data: Incomplete | None = ..., headers: Incomplete | None = ..., method: Incomplete | None = ...): ...
    def read(self, url, data: Incomplete | None = ...): ...
    def prepare_url(self, url): ...
    def delete(self, url): ...
    def http_error_default(self, url, fp, errcode, errmsg, headers) -> None: ...
    def http_error_400(self, url, fp, errcode, errmsg, headers, data: Incomplete | None = ...) -> None: ...
    def http_error_401(self, url, fp, errcode, errmsg, headers, data: Incomplete | None = ...) -> None: ...
    def http_error_403(self, url, fp, errcode, errmsg, headers, data: Incomplete | None = ...) -> None: ...
    def http_error_404(self, url, fp, errcode, errmsg, headers, data: Incomplete | None = ...) -> None: ...
    def http_error_500(self, url, fp, errcode, errmsg, headers, data: Incomplete | None = ...) -> None: ...
