=============================================================================
EXPERIMENT 087: COMPREHENSIVE GRAPH PROCESSOR PROFILING
Generated: 2025-11-07-23-03-02
=============================================================================

CONFIGURATION:
- GPU: Single GPU (no DDP)
- Dataset: 10,000 sample subset
- Batch size: 64 for DANGO, 28 for others
- Steps profiled: 100 (per run)

PURPOSE:
Compare all 5 graph processing methods under identical conditions:
1. DANGO (Perturbation) - Minimal graph data, fastest baseline
2. Lazy Hetero (LazySubgraphRepresentation) - Full graph + masks
3. NeighborSubgraph (1/2/3-hop) - Variable-sized k-hop neighborhoods

=============================================================================
RESULTS SUMMARY TABLE:
=============================================================================

| Method    | it/s      | Speedup   | GPU Mem   | Est. Max  | Nodes     | Edges     |
|           |           | vs DANGO  | (MB/batch)| Batch     | /sample   | /sample   |
|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| DANGO     | 545.120      | 1.00×     | 4.0       | 60       | 103.2       | 0.0       |
| LazySubg  | 1.433      | 0×     | 1155.4       | 973650       | 6607.0       | 2527683.0       |
| 1-hop     | 6.798      | .01×     | 88.7       | 60       | 697.0       | 196445.6       |
| 2-hop     | 2.499      | 0×     | 808.7       | 1488       | 3758.9       | 1878158.4       |
| 3-hop     | 2.136      | 0×     | 932.2       | 60       | 4508.1       | 2166602.5       |

=============================================================================
DETAILED ANALYSIS:
=============================================================================

**Speed Rankings (iterations/sec):**
1. DANGO:     545.120 it/s (baseline - minimal graph data)
2. Lazy:      1.433 it/s (0× vs DANGO)
3. 1-hop:     6.798 it/s (.01× vs DANGO, 4.74× vs Lazy)
4. 2-hop:     2.499 it/s (0× vs DANGO, 1.74× vs Lazy)
5. 3-hop:     2.136 it/s (0× vs DANGO, 1.49× vs Lazy)

**Memory Efficiency (GPU memory per batch):**
- DANGO:     4.0 MB (minimal - no graph edges)
- Lazy:      1155.4 MB (full graph for all samples)
- 1-hop:     88.7 MB (smallest subgraphs)
- 2-hop:     808.7 MB (medium subgraphs)
- 3-hop:     932.2 MB (largest subgraphs)

**Graph Size per Sample:**
- DANGO:     103.2 nodes, 0.0 edges (no graph in batch)
- Lazy:      6607.0 nodes, 2527683.0 edges (full 6607-node graph + masks)
- 1-hop:     697.0 nodes, 196445.6 edges
- 2-hop:     3758.9 nodes, 1878158.4 edges
- 3-hop:     4508.1 nodes, 2166602.5 edges

**Effective Throughput (samples/sec):**
- DANGO:     34887.680 samples/sec (batch=64)
- Lazy:      40.124 samples/sec (batch=28)
- 1-hop:     190.344 samples/sec (batch=28)
- 2-hop:     69.972 samples/sec (batch=28)
- 3-hop:     59.808 samples/sec (batch=28)

=============================================================================
KEY FINDINGS:
=============================================================================

1. **DANGO Performance:**
   - Fastest method (545.120 it/s) due to minimal graph data
   - Only stores perturbation indices, no graph structure in batches
   - Best for pure interaction prediction without graph context

2. **LazySubgraph vs NeighborSubgraph:**
   - Lazy uses full graph (6607.0 nodes) with boolean masks
   - 1-hop extracts ~697.0 nodes/sample (4.74× faster)
   - 2-hop extracts ~3758.9 nodes/sample (1.74× faster)
   - 3-hop extracts ~4508.1 nodes/sample (1.49× faster)

3. **Memory Tradeoffs:**
   - Smaller hop counts allow larger batch sizes
   - 1-hop: max batch ~60
   - 2-hop: max batch ~1488
   - 3-hop: max batch ~60
   - Lazy: max batch ~973650

=============================================================================
RECOMMENDATIONS:
=============================================================================

1. **If model needs full graph context:**
   → Consider LazySubgraph despite slower speed
   → All samples see complete 6607-node graph

2. **If local neighborhoods sufficient:**
   → Use 1-hop or 2-hop NeighborSubgraph
   → Significantly faster with reasonable context

3. **If speed is critical:**
   → Use DANGO for pure interaction prediction
   → Trade graph features for maximum throughput

4. **For production training:**
   → Balance between speed and model performance
   → Test model accuracy vs throughput for each method

=============================================================================
OUTPUT FILES:
=============================================================================

All profiling runs (DANGO, Lazy, 1/2/3-hop):
  experiments/006-kuzmin-tmi/profiling_results/profiling_087_2025-11-07-23-03-02/087_all_runs.log

Summary report (this file):
  experiments/006-kuzmin-tmi/profiling_results/profiling_087_2025-11-07-23-03-02/summary_2025-11-07-23-03-02.txt

SLURM scheduler output:
  experiments/006-kuzmin-tmi/slurm/output/PROFILE-087_532.out

=============================================================================
